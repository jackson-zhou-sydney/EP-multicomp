---
title: "Simulations for probit regression"
author: "Jackson Zhou"
date: "2022-10-09"
output: html_document
---

```{r Sourcing auxiliary functions}
library(tidyverse)        # Data manipulation and plotting
library(rstan)            # Robust MCMC and diagnostics
library(EnvStats)         # Compute empirical densities
library(detectseparation) # Detect separation in binary regression

source("../EP-general-auxiliaries.R")
source("Probit-auxiliaries.R")
```

```{r Generating random data}
set.seed(1)
n <- 100
p <- 10

sigma.2.beta.eg <- 10000

X.eg <- cbind(rep(1, n), matrix(data = rnorm(n = n*(p - 1)), nrow = n))
beta.eg <- c(rbind(rep(2, p/2), rep(-2, p/2)))/p
while (T) {
  y.eg <- rbinom(n = nrow(X.eg), size = 1, prob = pnorm(X.eg%*%beta.eg))
  separation <- glm(y.eg ~ X.eg, family = binomial(link = "probit"), method = "detect_separation")$separation
  if (!separation) break
}
```

```{r EP approximation}
set.seed(1)
ep.res <- ep.approx(X.eg, y.eg, sigma.2.beta.eg, alpha = 1,
                    max.passes = 200, tol.factor = Inf, stop.factor = Inf , abs.thresh = 0.5, 
                    rel.thresh = 0.9, delta.limit = Inf, patience = 40, verbose = T)
ep.mu <- ep.res$mu
ep.Sigma <- ep.res$Sigma
```

```{r MCMC approximation}
set.seed(1)
stan.res <- stan(file = "Probit-model.stan",
                 data = list(N = n,
                             p = p,
                             X = X.eg,
                             y = y.eg,
                             mu_beta = rep(0, p),
                             Sigma_beta = sigma.2.beta.eg*diag(p)),
                 chains = 1,
                 iter = 50000,
                 warmup = 5000,
                 init = "random") 

mcmc.samples <- rstan::extract(stan.res)$beta
mcmc.mu <- colMeans(mcmc.samples)
mcmc.Sigma <- var(mcmc.samples)
```

```{r Comparing approximations}
for (j in 1:p) {
  curve(demp(x, obs = mcmc.samples[, j]),
        from = mcmc.mu[j] - 5*sqrt(mcmc.Sigma[j, j]),
        to = mcmc.mu[j] + 5*sqrt(mcmc.Sigma[j, j]))
  abline(v = mcmc.mu[j], lty = 2)
  curve(dnorm(x, ep.mu[j], sqrt(ep.Sigma[j, j])), col = "red", add = TRUE)
}
```
